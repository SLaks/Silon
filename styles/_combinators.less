// The .op() mixin calls its @content callback iff the
// specified logical operation evaluates to true.  The
// input parameters (@first and @second) can either be
// selectors to combine (typically :checked selectors)
// or detached rulesets containing further .op() calls
// to chain.
// To pass a .op() call, use the following syntax:
// { .c(@c) { .op(@c, blah, xor, blah); } }
// We need this complexity to pass @invertCombinator &
// @content from the outer call; see 
// https://github.com/less/less.js/issues/2558

// This overload is called by the outermost operation,
// as opposed to operations passed as detached ruleset 
// parameters.  It calls the actual overloads with the
// default @invertCombinator and the explicitly-passed
// @content parameter
.op(@first, @operation, @second, @content) when (@operation = and), (@operation = xor), (@operation = or)  {
	.op(normal @content, @first, @operation, @second);   // Pass @content via scope
}

.op(@c, @first, @operation, @second) when (length(@c) > 1) {
	.op(@first, @operation, @second, extract(@c, 1), @content);
}

// These overloads are called in detached rulesets when chaining
.op(@first, xor, @second, normal, @content) {
	#private.callInverted(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
	#private.call(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
}
.op(@first, xor, @second, invert, @content) {
	#private.callInverted(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
	#private.call(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
}

.op(@first, or, @second, normal, @content) {
	#private.call(~'', @first, @content);
	#private.call(~'', @second, @content);
}
.op(@first, or, @second, invert, @content) {
	#private.callInverted(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
}

.op(@first, and, @second, normal, @content) {
	#private.call(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
}
.op(@first, and, @second, invert, @content) {
	#private.callInverted(~'', @first, @content);
	#private.callInverted(~'', @second, @content);
}

#private {
	// Calls a selector (as a string or a nested ruleset),
	// inside the context that this selector was called in
	.call(@combinator, @selector, @content) when (isString(@selector)) {
		&@{combinator}@{selector}:checked { @content(); }
	}
	.call(@combinator, @selector, @content) when  (isKeyword(@selector)) {
		&@{combinator}#@{selector}:checked { @content(); }
	}

	.call(@combinator, @selector, @content) when (default()) {  // isruleset(@selector) doesn't work
		&@{combinator} {
			@selector();
			.c(normal @content);
		}
	}

	// Same as above, but passes @invertCombinator
	// to invert the result of the combinator.
	.callInverted(@combinator, @selector, @content) when (isString(@selector)) {
		&@{combinator}@{selector}:not(:checked) { @content(); }
	}
	.callInverted(@combinator, @selector, @content) when (isKeyword(@selector)) {
		&@{combinator}#@{selector}:not(:checked) { @content(); }
	}

	.callInverted(@combinator, @selector, @content) when (default()) {  // isruleset(@selector) doesn't work
		&@{combinator} {
			@selector();
			.c(invert @content);
		}
	}
}