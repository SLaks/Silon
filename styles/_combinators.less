// The .op() mixin calls its @content callback iff the
// specified logical operation evaluates to true.  The
// input parameters (@first and @second) can either be
// selectors to combine (typically :checked selectors)
// or detached rulesets containing further .op() calls
// to chain.
// To pass a .op() call, use the following syntax:
// { .c(@c) { .op(@c, blah, xor, blah); } }
// We need this complexity to pass @invertCombinator &
// @content from the outer call; see 
// https://github.com/less/less.js/issues/2558

// This overload is called by the outermost operation,
// as opposed to operations passed as detached ruleset 
// parameters.  It calls the actual overloads with the
// default @invertCombinator and the explicitly-passed
// @content parameter
.op(@first, @operation, @second, @content) when (@operation = and), (@operation = xor), (@operation = or)  {
	.op(normal @content, @first, @operation, @second);   // Pass @content via scope
}

.op(@c, @first, @operation, @second) when (length(@c) > 1) {
	.op(@first, @operation, @second, extract(@c, 1), extract(@c, 2));
}

// These overloads are called in detached rulesets when chaining
.op(@first, xor, @second, normal, @content) {
	#private.callInverted(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
	#private.call(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
}
.op(@first, xor, @second, invert, @content) {
	#private.callInverted(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
	#private.call(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
}

.op(@first, or, @second, normal, @content) {
	#private.call(~'', @first, @content);
	#private.call(~'', @second, @content);
}
.op(@first, or, @second, invert, @content) {
	#private.callInverted(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
}

.op(@first, and, @second, normal, @content) {
	#private.call(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
}
.op(@first, and, @second, invert, @content) {
	#private.callInverted(~'', @first, @content);
	#private.callInverted(~'', @second, @content);
}

// Calls a selector (as a string or a nested ruleset),
// passing a context for inversion and target content.
// This should only be used for .op() chaining.
.callSelector(@c, @selector) when (isKeyword(@selector)) {
	.callSelector(@c, %(~'#%s', @selector));
}
.callSelector(@c, @selector, @mode: extract(@c, 1), @content: extract(@c, 2)) when (isString(@selector)) {
	&@{selector}:checked		when(@mode = normal) { @content(); }
	&@{selector}:not(:checked)	when(@mode = invert) { @content(); }
}
.callSelector(@c, @selector) when (default()) {  // isruleset(@selector) doesn't work
	@selector();
	.c(@c);
}

#private {
	// Calls a selector (as a string or a nested ruleset),
	// inside the context that this selector was called in
	.call(@combinator, @selector, @content) {
		&@{combinator} {
			.callSelector(normal @content, @selector);
		}
	}

	// Same as above, but passes @invertCombinator
	// to invert the result of the combinator.
	.callInverted(@combinator, @selector, @content) {
		&@{combinator} {
			.callSelector(invert @content, @selector);
		}
	}
}