// The .op() mixin calls its @content callback iff the
// specified logical operation evaluates to true.  The
// input parameters (@first and @second) can either be
// selectors to combine (typically :checked selectors)
// or detached rulesets containing further .op() calls
// to chain.
// To pass a .op() call, use the following syntax:
// { .c(@c) { .op(@c, blah, xor, blah); } }
// This is necessary to pass invertCombinator from the
// outer call (for xor); see 
// https://github.com/less/less.js/issues/2558

// This overload is called by the outermost operation,
// as opposed to operations passed as detached ruleset 
// parameters.  It calls the actual overloads with the
// default invertCombinator value, passing @content as
// a scoped variable.
.op(@first, @operation, @second, @content) when (@operation = and), (@operation = xor), (@operation = or)  {
	.op(false, @first, @operation, @second);	// Pass @content via scope
}

// These overloads are called in detached rulesets when chaining
.op(@invertCombinator, @first, @operation, @second) when (@operation = xor) and not (@invertCombinator) {
	#private.callInverted(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
	#private.call(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
}
.op(@invertCombinator, @first, @operation, @second) when (@operation = xor) and (@invertCombinator) {
	#private.callInverted(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
	#private.call(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
}

.op(@invertCombinator, @first, @operation, @second) when (@operation = or) and not (@invertCombinator) {
	#private.call(~'', @first, @content);
	#private.call(~'', @second, @content);
}
.op(@invertCombinator, @first, @operation, @second) when (@operation = or) and (@invertCombinator) {
	#private.callInverted(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
}

.op(@invertCombinator, @first, @operation, @second) when (@operation = and) and not (@invertCombinator) {
	#private.call(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
}
.op(@invertCombinator, @first, @operation, @second) when (@operation = and) and (@invertCombinator) {
	#private.callInverted(~'', @first, @content);
	#private.callInverted(~'', @second, @content);
}

#private {
	// Calls a selector (as a string or a nested ruleset),
	// inside the context that this selector was called in
	.call(@combinator, @selector, @content) when (isString(@selector)) {
		&@{combinator}@{selector}:checked { @content(); }
	}
	.call(@combinator, @selector, @content) when  (isKeyword(@selector)) {
		&@{combinator}#@{selector}:checked { @content(); }
	}

	.call(@combinator, @selector, @content) when (default()) {	// isruleset(@selector) doesn't work
		&@{combinator} {
			@selector();
			.c(false);
		}
	}

	// Same as above, but passes @invertCombinator
	// to invert the result of the combinator.
	.callInverted(@combinator, @selector, @content) when (isString(@selector)) {
		&@{combinator}@{selector}:not(:checked) { @content(); }
	}
	.callInverted(@combinator, @selector, @content) when (isKeyword(@selector)) {
		&@{combinator}#@{selector}:not(:checked) { @content(); }
	}

	.callInverted(@combinator, @selector, @content) when (default()) {	// isruleset(@selector) doesn't work
		&@{combinator} {
			@selector();
			.c(true);
		}
	}
}