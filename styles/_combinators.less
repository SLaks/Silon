// This overload is called by the outermost operation,
// as opposed to operations passed as detached ruleset 
// parameters).  It sets @invertCombinator, and passes
// @content as a scoped variable. This is necessary to
// prevent errors from the when() clauses.
.op(@first, @operation, @second, @content)  {
	@invertCombinator: false;
	.op(@first, @operation, @second);
}

.op(@first, @operation, @second) when (@operation = xor) and not (@invertCombinator) {
	#private.callInverted(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
	#private.call(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
}
.op(@first, @operation, @second) when (@operation = xor) and (@invertCombinator) {
	#private.callInverted(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
	#private.call(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
}

.op(@first, @operation, @second) when (@operation = or) and not (@invertCombinator) {
	#private.call(~'', @first, @content);
	#private.call(~'', @second, @content);
}
.op(@first, @operation, @second) when (@operation = or) and (@invertCombinator) {
	#private.callInverted(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
}

.op(@first, @operation, @second) when (@operation = and) and not (@invertCombinator) {
	#private.call(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
}
.op(@first, @operation, @second) when (@operation = and) and (@invertCombinator) {
	#private.callInverted(~'', @first, @content);
	#private.callInverted(~'', @second, @content);
}

#private {
	// Calls a selector (as a string or a nested ruleset),
	// inside the context that this selector was called in
	.call(@combinator, @selector, @content) when (isString(@selector)), (isKeyword(@selector)) {
		&@{combinator}@{selector}:checked { @content(); }
	}

	.call(@combinator, @selector, @content) when (default()) {	// isruleset(@selector) doesn't work
		&@{combinator} {
			@selector();
		}
	}

	// Same as above, but passes @invertCombinator
	// to invert the result of the combinator.
	.callInverted(@combinator, @selector, @content) when (isString(@selector)), (isKeyword(@selector)) {
		&@{combinator}@{selector}:not(:checked) { @content(); }
	}

	.callInverted(@combinator, @selector, @content) when (default()) {	// isruleset(@selector) doesn't work
		&@{combinator} {
			@invertCombinator: true;
			@selector();
		}
	}
}