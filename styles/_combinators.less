
.xor(@first, @second, @content: @content) {
	#private.callInverted(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
	#private.call(~'', @first, {
		#private.callInverted(~' ~ ', @second, @content);
	});
}

.or(@first, @second, @content: @content) {
	#private.call(~'', @first, @content);
	#private.call(~'', @second, @content);
}

.and(@first, @second, @content: @content) {
	#private.call(~'', @first, {
		#private.call(~' ~ ', @second, @content);
	});
}

// Calls a selector (as a string or a nested ruleset),
// inside the context that this selector was called in
#private {
	.call(@combinator, @selector, @content) when (isString(@selector)), (isKeyword(@selector)) {
		&@{combinator}@{selector}:checked { @content(); }
	}

	.call(@combinator, @selector, @content) when(default()) {	// isruleset(@selector) doesn't work
		&@{combinator} {
			@selector();
		}
	}
	.callInverted(@combinator, @selector, @content) when (isString(@selector)), (isKeyword(@selector)) {
		&@{combinator}@{selector}:not(:checked) { @content(); }
	}
}