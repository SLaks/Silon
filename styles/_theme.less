@import "_mixins";

@remSize: 16px;

@background: #FFF3E0;
@borderColor: #FFA000;
@inactiveColor: #E0E0E0;
@inactiveHoverColor: #B3E5FC;
@activeColor: #FFC107;
@activeHoverColor: #FFB300;

@transitionDuration: cubic-bezier(.4, 0, .2, 1) .3s;

@borderThickness: 2px / @remSize * 1rem;
@border: @borderThickness solid @borderColor;

@valueSize: 3rem;

:root {
	font-size: @remSize; // Layout base unit
	box-sizing: border-box;
}

// Applies properties to all connectors that immediately follow the containing
// element. Use this mixin to style connectors depending on the state of their 
// connectee.  
.ConnectorsFor(@content) {
	.Recurse(3, {	// We currently only ever have three levels of connectors
		&, &:before { @content(); }
	});

	.Recurse(@count, @content) {
		+ .Connector { @content(); }
	}

	.Recurse(@count, @content) when (@count > 1) {
		+ .Connector {	
			.Recurse(@count - 1, @content);
		}
	}
}

// Draws a box around a value (input or computed result).  The caller 
// must apply background-color: @activeColor when the value is active
.ValueBox() {
	display: block;
	.square(@valueSize);
	box-sizing: border-box;
	background-color: @inactiveColor;
	border: @border;
	transition: background @transitionDuration;
}

// Draws the content of a value. The caller must apply
// .ActiveValueContent() whenever the value is active.
.ValueContent() {
	position: relative;
	overflow: hidden;
	&:after {
		white-space: pre;
		content: '0\00000a1';
		font-size: 2rem;
		display: block;
		.square(@valueSize);
		line-height: @valueSize;
		text-align: center;
		position: absolute;
		top: 0;
		transition: top @transitionDuration;
	}
}


// Applies active styles to a .ValueContent() element
.ActiveValueContent() {
	&:after {
		top: -@valueSize;
	}

	.ConnectorsFor({
		background-color: @activeColor;
	});
}

.Canvas input[type=checkbox] {
	.square(@valueSize);
	margin: 0;
	padding: 0;

	&:before {
		content: '';
		.ValueBox();
	}
	&:checked:before {
		background-color: @activeColor;
	}

	.ValueContent();
	&:checked {
		.ActiveValueContent();
	}

	&:hover {
		&:before {
			background-color: @inactiveHoverColor;
		}
		.ConnectorsFor({
			background-color: @inactiveHoverColor;
		});

		&:checked {
			&:before {
				background-color: @activeHoverColor;
			}
			.ConnectorsFor({
				background-color: @activeHoverColor;
			});
		}
	}
}


.Canvas {
	@padding: .5rem;
	position: relative;

	// Add spacing around the content, without affecting
	// the offsets of absolutely positioned children, by
	// making the background & border extend outside the
	// element's boundaries
	overflow: visible;
	margin: @padding;
	&:before {
		content: '';
		display: block;
		background-color: @background;
		border: 2px solid #FFB74D;
		position: absolute;
		top: -@padding;
		left: -@padding;
		right: -@padding;
		bottom: -@padding;
	}

	> * {
		position: absolute !important;	// Override position: relative from checkboxes
	}
}

// A line connecting value boxes or combinators.
// These lines are laid out in style attributes,
// as if the line had zero thickness. Therefore,
// the position (top or left) sets the center of
// the line.
.Connector {
	background: @inactiveColor;
	transition: background @transitionDuration;
	// Add padding to the cross axis to cover
	// the border of the connected elements.
	box-sizing: content-box;
	z-index: 1;	 // Cover the borders of subsequent connectors.

	@thickness: .5rem; // The length in the cross axis
	@centerOffset: .5 * @thickness + @borderThickness;	// The distance from the left edge to the center

	// Corners cover the joint between two connectors,
	// as a class applied to the second element.  They
	// are centered around the overlapping centers for
	// their two adjacent connectors, and have borders
	// to close the edges.
	&.Corner:before {
		content: '';
		display: block;
		position: absolute;

		// The corner must have the same dimensions as
		// the connectors.  Borders are added by every
		// direction separately for the correct sides.
		.square(@thickness);
		transition: inherit;
		// Using inherit adds unwanted cascade to animations
		background-color: @inactiveColor;
	}

	&.Vertical {
		// Center the element in the cross axis, around the declared position
		width: @thickness;
		margin-left: -@centerOffset;

		// Offset adjacent borders
		margin-top: -@borderThickness;
		padding: @borderThickness 0;

		border-left: @border;
		border-right: @border;
		
		&.Corner:before {
			top: -.5 * @thickness;		// Cover the thickness of the adjoining connector, which is centered at our top
			left: -@borderThickness;	// Cover the parent's outer border
			border-top: @border;
			// Don't pad the edge facing our connector, 
			// so that the connector's border can cover
			// the pixel at the bend.
		}

		&.Corner.Left:before {
			border-right: @border;
			padding-left: @borderThickness;	// Stretch over the adjoining connector's borders
		}

		&.Corner.Right:before {
			border-left: @border;
			padding-right: @borderThickness;
		}

	}

	&.Horizontal {
		// Center the element in the cross axis, around the declared position
		height: @thickness;
		margin-top: -@centerOffset;

		// Offset adjacent borders
		margin-left: -@borderThickness;
		padding: 0 @borderThickness;
		
		border-top: @border;
		border-bottom: @border;
		
		&.Corner.Left:before {
			left: -.5 * @thickness;	// Cover the thickness of the adjoining connector, which is centered at our left
			top: -@borderThickness;	// Cover the parent's outer border
			border-left: @border;
		}

		&.Corner.Right:before {
			right: -.5 * @thickness; // Cover the thickness of the adjoining connector, which is centered at our right
			top: -@borderThickness;	 // Cover the parent's outer border
			border-right: @border;
		}

		&.Corner.Up:before {
			border-bottom: @border;
			padding-top: @borderThickness;
		}

		&.Corner.Down:before {
			border-top: @border;
			padding-bottom: @borderThickness;
		}
	}
}

.Result {
	border-radius: @valueSize / 2;
	.ValueBox();
	.ValueContent();
}

// Applied to output values (.Result) when the logic gate evaluates to true.
.On() {
	background-color: @activeColor;
	.ActiveValueContent();
}

.Gate-XOR, .Gate-OR {
	@straightHeight: 1rem;
	@tipHeight: 3rem;
	@width: 4rem;
	@tipRadii: @width @tipHeight * 1.4;
	@cutoutDiameter: @width * 1.8;

	position: relative;
	width: @width;
	height: @straightHeight + @tipHeight;
	z-index: 0;
	margin-top: -0.3rem;
	overflow: hidden; // Hide the rest of the concave circle (see below)
	// The straight portion is a separate element,
	// because it is shorter than the full parent.
	&:after {
		content: '';
		display: block;
		height: @straightHeight;
		background-color: @inactiveColor;
		border-left: @border;
		border-right: @border;
	}
	// The concave curve on the top is implemented
	// as a large circle with the background color
	// to cover the top part of the straight part.
	&:before {
		content: '';
		display: block;
		.square(@cutoutDiameter);
		left: -(@cutoutDiameter - @width) / 2;
		top: -@cutoutDiameter * .9;
		box-sizing: border-box;
		border-radius: 50%;
		position: absolute;
		background-color: @background;
		border: @border;
	}
	// To make the lower curve stop at an angle,
	// I make two curves that cover the complete
	// width of the element, and cut off half of
	// each one so that they meet in the middle.
	span {
		display: block;
		position: absolute;
		top: @straightHeight;
		height: @tipHeight;
		width: @width / 2;
		overflow: hidden;

		&:before {
			content: '';
			display: block;
			background-color: @inactiveColor;
			border-bottom: @border;
			position: absolute;
			height: @tipHeight;
			width: @width;
		}
	}

	span:first-child {
		left: 0;

		&:before {
			border-left: @border;
			border-bottom-left-radius: @tipRadii;
		}
	}

	span + span {
		right: 0;

		&:before {
			right: 0;
			border-right: @border;
			border-bottom-right-radius: @tipRadii;
		}
	}
}
