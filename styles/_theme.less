@import "_mixins";

@borderColor: #FFA000;
@inactiveColor: #E0E0E0;
@inactiveHoverColor: #B3E5FC;
@activeColor: #FFC107;
@activeHoverColor: #FFB300;

@transitionDuration: cubic-bezier(.4, 0, .2, 1) .3s;

@borderThickness: 2px;
@border: @borderThickness solid @borderColor;

@valueSize: 3rem;

:root {
	font-size: 16px; // Layout base unit
}

* {
	box-sizing: border-box;
}

// Applies properties to all connectors that immediately follow the containing
// element. Use this mixin to style connectors depending on the state of their 
// connectee.  
.ConnectorsFor(@content) {
	.Recurse(3, {	// We currently only ever have three levels of connectors
		&, &:before { @content(); }
	});

	.Recurse(@count, @content) {
		+ .Connector { @content(); }
	}

	.Recurse(@count, @content) when (@count > 1) {
		+ .Connector {	
			.Recurse(@count - 1, @content);
		}
	}
}

.ValueBox() {
	display: block;
	.square(@valueSize);
	box-sizing: border-box;
	background-color: @inactiveColor;
	border: @border;
	transition: background @transitionDuration;
}

.ValueContent() {
	&:after {
		white-space: pre;
		content: '0\00000a1';
		font-size: 2rem;
		display: block;
		.square(@valueSize);
		line-height: @valueSize;
		text-align: center;
		position: absolute;
		top: 0;
		transition: top @transitionDuration;
	}
}


.ActiveValue() {
	&:after {
		top: -@valueSize;
	}

	.ConnectorsFor({
		background-color: @activeColor;
	});
}


input[type=checkbox] {
	-moz-appearance: none;
	position: relative;
	.square(@valueSize);
	overflow: hidden;
	margin: 0;
	padding: 0;

	&:before {
		content: '';
		.ValueBox();
	}

	&:checked:before {
		background-color: @activeColor;
	}

	.ValueContent();

	&:checked {
		.ActiveValue();
	}

	&:hover {
		&:before {
			background-color: @inactiveHoverColor;
		}
		.ConnectorsFor({
			background-color: @inactiveHoverColor;
		});
		&:checked {
			&:before {
				background-color: @activeHoverColor;
			}
			.ConnectorsFor({
				background-color: @activeHoverColor;
			});
		}
	}
}

.Canvas {
	@padding: .5rem;
	position: relative;
	overflow: visible;
	box-sizing: content-box;
	margin: @padding;

	&:before {
		content: '';
		display: block;
		background-color: #FFF3E0;
		border: 2px solid #FFB74D;
		position: absolute;
		top: -@padding;
		left: -@padding;
		right: -@padding;
		bottom: -@padding;
	}

	> * {
		position: absolute !important;
	}
}

.Connector {
	z-index: 1;
	background: @inactiveColor;
	transition: background @transitionDuration;
	// Use padding to add an additional pixel to the declared size to cover the adjacent borders.
	box-sizing: content-box;

	@thickness: .5rem;

	&.Vertical {
		width: @thickness;
		margin-left: calc((-.5 * @thickness) ~" - " @borderThickness);
		margin-top: -@borderThickness;
		padding: @borderThickness 0;
		border-left: @border;
		border-right: @border;
		
		&.Corner:before {
			border-top: @border;
			padding-bottom: @borderThickness;
			top: -.5 * @thickness;
			left: -@borderThickness;
		}

		&.Corner.Left:before {
			border-right: @border;
			padding-left: @borderThickness;
		}

		&.Corner.Right:before {
			border-left: @border;
			padding-right: @borderThickness;
		}

	}

	&.Horizontal {
		height: @thickness;
		margin-top: calc((-.5 * @thickness) ~" - " @borderThickness);
		margin-left: -@borderThickness;
		padding: 0 @borderThickness;
		border-top: @border;
		border-bottom: @border;
		
		&.Corner.Left:before {
			border-left: @border;
			padding-right: @borderThickness;
			left: -.5 * @thickness;
			top: -@borderThickness;
		}

		&.Corner.Right:before {
			border-right: @border;
			padding-left: @borderThickness;
			right: -.5 * @thickness;
			top: -@borderThickness;
		}

		&.Corner.Up:before {
			border-bottom: @border;
			padding-top: @borderThickness;
		}

		&.Corner.Down:before {
			border-top: @border;
			padding-bottom: @borderThickness;
		}
	}

	&.Corner:before {
		content: '';
		display: block;
		position: absolute;
		box-sizing: inherit;
		transition: inherit;
		background-color: @inactiveColor;
		.square(@thickness);
	}
}


.Result {
	overflow: hidden;
	position: relative;
	border-radius: @valueSize / 2;
	.ValueBox();
	.ValueContent();
}

.On() {
	background-color: @activeColor;
	.ActiveValue();
}
